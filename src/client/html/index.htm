<!doctype html>
<!--
/*
 * Copyright (c) 2016 Erik Nordstrøm <erik@nordstroem.no>
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
-->
<html lang=en-US>
<meta charset=UTF-8>
<meta name="viewport"
  content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Klondike</title>
<style>
body { background: #066; }
canvas { background: #063; }
</style>
<canvas id=game width=480 height=480></canvas>
<script id=ks>
document.body.addEventListener('touchmove', function (event) {
	event.preventDefault();
}, false);

var g = document.getElementById('game');
var gtx = g.getContext('2d');

var t = document.createElement('canvas');
t.width = g.width;
t.height = g.height;
var ttx = t.getContext('2d');

var pk = document.createElement('canvas');
pk.width = g.width;
pk.height = g.height;
var pktx = pk.getContext('2d');

var pt = document.createElement('canvas');
pt.width = g.width;
pt.height = g.height;
var pttx = pt.getContext('2d');

// Sizes measured in ratios.
const CARDWIDTH = 2.25;
const CARDHEIGHT = 3.50;
const DISTVERT = 0.5; // vertical distance
const DISTHORZ = 0.5; // horizontal distance
const MARGINTOP = DISTVERT;
const MARGINRIGHT = DISTHORZ;
const MARGINBOTTOM = DISTVERT;
const MARGINLEFT = DISTHORZ;
const CANVASWIDTH = MARGINLEFT + 7 * CARDWIDTH + 6 * DISTHORZ + MARGINRIGHT;
const CANVASHEIGHT = MARGINTOP + 2 * CARDHEIGHT + DISTVERT + 24 * DISTVERT
	+ MARGINBOTTOM;

var gf = document.createElement('canvas');
gf.width = Math.floor(CARDWIDTH * (g.width / CANVASWIDTH));
gf.height = Math.floor((12 * DISTVERT + CARDHEIGHT)
	* (g.height / CANVASHEIGHT));
var gftx = gf.getContext('2d');

var debug = window.location.search.replace("?", "") === 'DEBUG';
if (debug)
{
	var ks = document.getElementById('ks');

	t.setAttribute('id', 'table');
	document.body.insertBefore(t, ks);
	document.body.insertBefore(document.createTextNode('\n'), ks);
	pk.setAttribute('id', 'pkabl');
	document.body.insertBefore(pk, ks);
	document.body.insertBefore(document.createTextNode('\n'), ks);
	pt.setAttribute('id', 'ptabl');
	document.body.insertBefore(pt, ks);
	document.body.insertBefore(document.createTextNode('\n'), ks);
	gf.setAttribute('id', 'gfore');
	document.body.insertBefore(gf, ks);
	document.body.insertBefore(document.createTextNode('\n'), ks);
}

const enum_color =
{
	NO_COLOR : 0,
	HEARTS : 1,
	SPADES : 2,
	DIAMONDS : 3,
	CLUBS : 4,
	UNKNOWN_COLOR : 5
};

const enum_rank =
{
	NO_RANK : 0,
	ACE : 1,
	TWO : 2,
	THREE : 3,
	FOUR : 4,
	FIVE : 5,
	SIX : 6,
	SEVEN : 7,
	EIGHT : 8,
	NINE : 9,
	TEN : 10,
	JACK : 11,
	QUEEN : 12,
	KING : 13,
	UNKNOWN_RANK : 14
};

const symb_color = ['', '♥', '♠', '♦', '♣', ''];

const symb_rank = ['', 'A', '2', '3', '4', '5', '6',
	'7', '8', '9', '10', 'J', 'Q', 'K', ''];

const NULLCARD = 0;
const UNKNOWNCARD = 94;

const FACE_UP = Math.pow(2, 7);

const MASK_COLOR = 7 << 4;
const MASK_RANK = 15;

function isFacingUp (card)
{
	return card & FACE_UP;
}

function getColor (card)
{
	return (card & MASK_COLOR) >> 4;
}

function getRank (card)
{
	return card & MASK_RANK;
}

class RenderableCard
{
	constructor (card, x, y, origin, oidx, subarr)
	{
		this.card = card;
		this.x = x;
		this.y = y;
		this.origin = origin;
		this.oidx = oidx;
		this.subarr = subarr;
	}
}

var table = {};
table.deck =
{
	x : MARGINLEFT,
	y : MARGINTOP,
	cards : new Array(),
	getRLVisible : function ()
	{
		if (this.cards.length > 0)
		{
			return [new RenderableCard(
				this.cards[this.cards.length - 1],
				this.x, this.y, this.cards,
				this.cards.length - 1, null)];
		}

		return [];
	}
	// Deck is not pickable.
	// Deck is not putable.
};
table.waste =
{
	x : MARGINLEFT + CARDWIDTH + DISTHORZ,
	y : MARGINTOP,
	cards : new Array(),
	getRLVisible : function ()
	{
		var ret = [];

		var n = Math.min(3, this.cards.length);
		for (var i = n ; i > 0 ; i--)
		{
			ret.push(new RenderableCard(
				this.cards[this.cards.length - i],
				this.x + (n - i) * DISTHORZ,
				this.y, this.cards,
				this.cards.length - i, null));
		}

		return ret;
	},
	getRLPickable : function ()
	{
		/*
		 * XXX: Calling this.getRLVisible is
		 * not *ideal* but it saves some typing.
		 */
		var v = this.getRLVisible();
		if (v.length > 0)
		{
			return [v[v.length - 1]];
		}
		return [];
	}
	// Waste is not putable.
};
table.foundation =
{
	x : MARGINLEFT + 3 * (CARDWIDTH + DISTHORZ),
	y : MARGINTOP,
	cards : new Array(),
	getRLVisible : function ()
	{
		var ret = [];

		for (var i = 0 ; i < 4 ; i++)
		{
			ret.push(new RenderableCard(
				this.cards[i],
				this.x + i * (CARDWIDTH + DISTHORZ),
				this.y, this.cards, i, null));
		}

		return ret;
	},
	getRLPickable : function ()
	{
		var ret = [];

		// XXX: Using getRLVisible is about as good as anything here.
		this.getRLVisible().forEach(function (e)
		{
			if (e.card)
			{
				ret.push(e);
			}
		});

		return ret;
	},
	getRLPutable : function ()
	{
		var ret = [];

		if (hand.rl.length == 1)
		{
			var h = hand.rl[0].card;
			// XXX: getRLVisible is about as good as anything here.
			this.getRLVisible().forEach(function (e)
			{
				var c = e.card;
				if ((getColor(c) == getColor(h)
						&& (getRank(c) + 1)
							== getRank(h))
					|| (!c && getRank(h) == enum_rank.ACE))
				{
					ret.push(e);
				}
			});
		}

		return ret;
	}
};
table.tableau =
{
	x : MARGINLEFT,
	y : MARGINTOP + CARDHEIGHT + DISTVERT,
	cards : new Array([], [], [], [], [], [], []),
	getRLVisible : function ()
	{
		var ret = [];

		for (var i = 0 ; i < 7 ; i++)
		{
			for (var j = 0 ; j < this.cards[i].length ; j++)
			{
				ret.push(new RenderableCard(
					this.cards[i][j],
					this.x + i * (CARDWIDTH + DISTHORZ),
					this.y + j * DISTVERT, this.cards,
					j, i));
			}
		}

		return ret;
	},
	getRLPickable : function ()
	{
		var ret = [];

		// XXX: Using getRLVisible is about as good as anything here.
		this.getRLVisible().forEach(function (e)
		{
			if (isFacingUp(e.card))
			{
				ret.push(e);
			}
		});

		return ret;
	},
	getRLPutable : function (card)
	{
		var ret = [];

		// TODO: Implement

		return ret;
	}
};
table.getRLVisible = function ()
{
	/*
	 * XXX: I prefer prototype call. I find it
	 *      to be more readable than calling
	 *      concat on first array with
	 *      the others as arguments.
	 */
	return Array.prototype.concat.call(
		this.deck.getRLVisible(),
		this.waste.getRLVisible(),
		this.foundation.getRLVisible(),
		this.tableau.getRLVisible());
};
table.getRLPickable = function ()
{
	return Array.prototype.concat.call(
		this.waste.getRLPickable(),
		this.foundation.getRLPickable(),
		this.tableau.getRLPickable());
};
table.getRLPutable = function ()
{
	return Array.prototype.concat.call(
		this.foundation.getRLPutable(),
		this.tableau.getRLPutable());
};
table.initialize = function ()
{
	/*
	 * Initialize game.
	 *
	 * TODO: Get initial state from server.
	 */

	// Initialize deck
	//for (var i = 0 ; i < 24 ; i++)
	for (var i = 0 ; i < 18 ; i++)
	{
		this.deck.cards[i] = UNKNOWNCARD;
	}

	// Waste is empty as it should be. No further initialization required.
	// Initialize with a few cards for testing.
	this.waste.cards = [43 | FACE_UP, 42 | FACE_UP, 41 | FACE_UP,
		36 | FACE_UP, 18 | FACE_UP, 17 | FACE_UP];

	// Initialize foundations
	for (var i = 0 ; i < 4 ; i++)
	{
		this.foundation.cards[i] = NULLCARD;
	}

	// Initialize tableaus
	for (var i = 0 ; i < 7 ; i++)
	{
		var j;
		for (j = 0 ; j < i ; j++)
		{
			this.tableau.cards[i][j] = UNKNOWNCARD;
		}
	}
	this.tableau.cards[0][0] = 21 | FACE_UP;
	this.tableau.cards[1][1] = 19 | FACE_UP;
	this.tableau.cards[2][2] = 61 | FACE_UP;
	this.tableau.cards[3][3] = 56 | FACE_UP;
	this.tableau.cards[4][4] = 52 | FACE_UP;
	this.tableau.cards[5][5] = 49 | FACE_UP;
	this.tableau.cards[6][6] = 44 | FACE_UP;
};

table.initialize();

function cardRenderer (c, ctx)
{
	return function (rc, idx)
	{
		var sx = Math.floor(rc.x * (c.width / CANVASWIDTH));
		var sy = Math.floor(rc.y * (c.height / CANVASHEIGHT));
		var sw = Math.floor(CARDWIDTH * (c.width / CANVASWIDTH));
		var sh = Math.floor(CARDHEIGHT * (c.height / CANVASHEIGHT));

		if (rc.card)
		{
			ctx.fillStyle = 'rgb(0,0,0)';
			ctx.fillRect(sx, sy, sw, sh);

			if (isFacingUp(rc.card))
			{
				ctx.fillStyle = 'rgb(255,255,255)';
				ctx.fillRect(sx + 1, sy + 1, sw - 2, sh - 2);
				ctx.fillStyle = 'rgb('
					+ (getColor(rc.card) & 1) * 255
					+ ',0,0)';
				ctx.textBaseline = 'top';
				ctx.fillText(symb_rank[getRank(rc.card)]
					+ symb_color[getColor(rc.card)],
					sx + 3, sy + 4);
			}
			else
			{
				ctx.fillStyle = 'rgb(0,0,255)';
				ctx.fillRect(sx + 1, sy + 1, sw - 2, sh - 2);
			}
		}
		else
		{
			ctx.fillStyle = 'rgb(128,128,128)';
			ctx.fillRect(sx, sy, sw, sh);
		}
	}
}

function cardIdxRenderer (c, ctx)
{
	return function (rc, idx)
	{
		ctx.fillStyle = 'rgb(' + (4 * idx + 1) + ',0,0)';
		ctx.fillRect(Math.floor(rc.x * (c.width / CANVASWIDTH)),
			Math.floor(rc.y * (c.height / CANVASHEIGHT)),
			Math.floor(CARDWIDTH * (c.width / CANVASWIDTH)),
			Math.floor(CARDHEIGHT * (c.height / CANVASHEIGHT)));
	}
}

var hand = {};
hand.x = 0;
hand.y = 0;
hand.offs_x = 0;
hand.offs_y = 0;
hand.rl = new Array();

function renderCard (c, ctx, card, rx, ry)
{
	ctx.fillStyle = 'rgb(' + card + ',0,0)';
	ctx.fillRect(Math.floor(rx * (c.width / CANVASWIDTH)),
		Math.floor(ry * (c.height / CANVASHEIGHT)),
		Math.floor(CARDWIDTH * (c.width / CANVASWIDTH)),
		Math.floor(CARDHEIGHT * (c.height / CANVASHEIGHT)));
}

var renderRenderableCardToTable = cardRenderer(t, ttx);
function renderTable ()
{
	ttx.clearRect(0, 0, t.width, t.height);

	table.getRLVisible().forEach(renderRenderableCardToTable);
}

var renderRenderableCardToPickable = cardIdxRenderer(pk, pktx);
function renderPickable ()
{
	pktx.clearRect(0, 0, pk.width, pk.height);

	table.getRLPickable().forEach(renderRenderableCardToPickable);
}

var renderRenderableCardToPutable = cardIdxRenderer(pt, pttx);
function renderPutable ()
{
	pttx.clearRect(0, 0, pt.width, pt.height);

	table.getRLPutable().forEach(renderRenderableCardToPutable);
}

// XXX: We pass g instead of gf since card size is calculated from canvas size.
var renderRenderableCardToHand = cardRenderer(g, gftx);
function renderHand ()
{
	gftx.clearRect(0, 0, gf.width, gf.height);

	hand.rl.forEach(renderRenderableCardToHand);
}

function renderGame ()
{
	gtx.clearRect(0, 0, g.width, g.height);

	gtx.drawImage(t, 0, 0);

	if (hand.rl.length > 0)
	{
		gtx.drawImage(gf, hand.x - hand.offs_x, hand.y - hand.offs_y);
		window.requestAnimationFrame(renderGame);
	}
}

function updateHandPos (e)
{
	var x, y;
	if (window.TouchEvent && e instanceof TouchEvent)
	{
		x = e.touches[0].pageX - g.offsetLeft;
		y = e.touches[0].pageY - g.offsetTop;
	}
	else
	{
		x = e.layerX;
		y = e.layerY;
	}

	hand.x = x;
	hand.y = y;

	// XXX: Limit x to margins
	hand.x = Math.max(0.1 * g.width
			- CARDWIDTH * (g.width / CANVASWIDTH),
		Math.min(x, 0.9 * g.width));
	// XXX: Limit y to margins
	hand.y = Math.max(0.1 * g.height
			- CARDHEIGHT * (g.height / CANVASHEIGHT),
		Math.min(y, 0.9 * g.height));
}

function pick (e)
{
	updateHandPos(e);

	var pixel = pktx.getImageData(hand.x, hand.y, 1, 1);
	var val = pixel.data[0];

	if (val)
	{
		var card = table.getRLPickable()[(val - 1) / 4];
		var cards;
		if (card.subarr === null)
		{
			cards = card.origin.splice(card.oidx);
		}
		else
		{
			cards = card.origin[card.subarr].splice(card.oidx);
		}

		hand.offs_x = hand.x -
			Math.floor(card.x * (g.width / CANVASWIDTH));
		hand.offs_y = hand.y -
			Math.floor(card.y * (g.height / CANVASHEIGHT));

		for (var i = 0 ; i < cards.length ; i++)
		{
			hand.rl.push(new RenderableCard(cards[i],
				0, i * DISTVERT, card.origin,
				card.oidx, card.subarr));
		}

		renderHand();
		renderPutable();
		renderTable();
		window.requestAnimationFrame(renderGame);
	}
}
g.addEventListener('mousedown', pick);
g.addEventListener('touchstart', pick);

function transpose (e)
{
	if (hand.rl.length > 0)
	{
		updateHandPos(e);
	}
}
g.addEventListener('mousemove', transpose);
g.addEventListener('touchmove', transpose);

function place (e)
{
	if (hand.rl.length > 0)
	{
		updateHandPos(e);

		var pixel = pttx.getImageData(hand.x, hand.y, 1, 1);
		var val = pixel.data[0];
		var tgt;

		if (val)
		{
			tgt = table.getRLPutable()[(val - 1) / 4];
		}
		else
		{
			tgt = hand.rl[0];
		}
		var cards = hand.rl.splice(0).map(function (e)
		{
			return e.card;
		});

		if (tgt.card)
		{
			if (tgt.subarr === null)
			{
				Array.prototype.push.apply(tgt.origin, cards);
			}
			else
			{
				Array.prototype.push.apply(
					tgt.origin[tgt.subarr], cards);
			}
		}
		else
		{
			tgt.origin[tgt.oidx] = cards[0];
		}

		renderTable();
		renderPickable();
	}
}
g.addEventListener('mouseup', place);
g.addEventListener('mouseout', place);
g.addEventListener('touchend', place);

renderTable();
renderPickable();
renderGame();
</script>
