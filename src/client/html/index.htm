<!doctype html>
<!--
/*
 * Copyright (c) 2016 Erik NordstrÃ¸m <erik@nordstroem.no>
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
-->
<html lang=en-US>
<meta charset=UTF-8>
<meta name="viewport"
  content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Klondike</title>
<style>
body { background: #066; }
canvas { background: #063; }
</style>
<canvas id=game width=480 height=480></canvas>
<canvas id=table></canvas>
<canvas id=pkabl></canvas>
<canvas id=ptabl></canvas>
<canvas id=gfore></canvas>
<script>
document.body.addEventListener('touchmove', function(event) {
	event.preventDefault();
}, false);

var g = document.getElementById('game');
var gtx = g.getContext('2d');

var t = document.getElementById('table');
//var t = document.createElement('canvas');
t.width = g.width;
t.height = g.height;
var ttx = t.getContext('2d');

var pk = document.getElementById('pkabl');
//var pk = document.createElement('canvas');
pk.width = g.width;
pk.height = g.height;
var pktx = pk.getContext('2d');

var pt = document.getElementById('ptabl');
//var pt = document.createElement('canvas');
pt.width = g.width;
pt.height = g.height;
var pttx = pt.getContext('2d');

// Sizes measured in ratios.
const CARDWIDTH = 2.25;
const CARDHEIGHT = 3.50;
const DISTVERT = 0.5; // vertical distance
const DISTHORZ = 0.5; // horizontal distance
const MARGINTOP = DISTVERT;
const MARGINRIGHT = DISTHORZ;
const MARGINBOTTOM = DISTVERT;
const MARGINLEFT = DISTHORZ;
const CANVASWIDTH = MARGINLEFT + 7 * CARDWIDTH + 6 * DISTHORZ + MARGINRIGHT;
const CANVASHEIGHT = MARGINTOP + 2 * CARDHEIGHT + DISTVERT + 24 * DISTVERT
	+ MARGINBOTTOM;

var gf = document.getElementById('gfore');
//var gf = document.createElement('canvas');
gf.width = Math.floor(CARDWIDTH * (g.width / CANVASWIDTH));
gf.height = Math.floor((12 * DISTVERT + CARDHEIGHT)
	* (g.height / CANVASHEIGHT));
var gftx = gf.getContext('2d');

const enum_color =
{
	NO_COLOR : 0,
	HEARTS : 1,
	SPADES : 2,
	DIAMONDS : 3,
	CLUBS : 4,
	UNKNOWN_COLOR : 5
};

const enum_rank =
{
	NO_RANK : 0,
	ACE : 1,
	TWO : 2,
	THREE : 3,
	FOUR : 4,
	FIVE : 5,
	SIX : 6,
	SEVEN : 7,
	EIGHT : 8,
	NINE : 9,
	TEN : 10,
	JACK : 11,
	QUEEN : 12,
	KING : 13,
	UNKNOWN_RANK : 14
};

const NULLCARD = 0;
const UNKNOWNCARD = 94;

const FACE_UP = Math.pow(2, 7);

const MASK_COLOR = 7 << 4;
const MASK_RANK = 15;

class RenderableCard
{
	constructor (card, x, y, origin, oidx)
	{
		this.card = card;
		this.x = x;
		this.y = y;
		this.origin = origin;
		this.oidx = oidx;
	}
}

function isFacingUp (card)
{
	return card & FACE_UP;
}

function getColor (card)
{
	return (card & MASK_COLOR) >> 4;
}

function getRank (card)
{
	return card & MASK_RANK;
}

var table = {};
table.deck =
{
	x : MARGINLEFT,
	y : MARGINTOP,
	cards : new Array(),
	getRLVisible : function ()
	{
		if (this.cards.length > 0)
		{
			return [new RenderableCard(
				this.cards[this.cards.length - 1],
				this.x, this.y, this.cards,
				this.cards.length - 1)];
		}

		return [];
	}
	// Deck is not pickable.
	// Deck is not putable.
};
table.waste =
{
	x : MARGINLEFT + CARDWIDTH + DISTHORZ,
	y : MARGINTOP,
	cards : new Array(),
	getRLVisible : function ()
	{
		var ret = [];

		var n = Math.min(3, this.cards.length);
		for (var i = n ; i > 0 ; i--)
		{
			ret.push(new RenderableCard(
				this.cards[this.cards.length - i],
				this.x + (n - i) * DISTHORZ,
				this.y, this.cards,
				this.cards.length - i));
		}

		return ret;
	},
	getRLPickable : function ()
	{
		/*
		 * XXX: Calling this.getRLVisible is
		 * not *ideal* but it saves some typing.
		 */
		var v = this.getRLVisible();
		if (v.length > 0)
		{
			return [v[v.length - 1]];
		}
		return [];
	}
	// Waste is not putable.
};
table.foundation =
{
	x : MARGINLEFT + 3 * (CARDWIDTH + DISTHORZ),
	y : MARGINTOP,
	cards : new Array(),
	getRLVisible : function ()
	{
		var ret = [];

		for (var i = 0 ; i < 4 ; i++)
		{
			ret.push(new RenderableCard(
				this.cards[i],
				this.x + i * (CARDWIDTH + DISTHORZ),
				this.y, this.cards, i));
		}

		return ret;
	},
	getRLPickable : function ()
	{
		var ret = [];

		// XXX: Using getRLVisible is about as good as anything here.
		this.getRLVisible().forEach(function (e)
		{
			if (e.card)
			{
				ret.push(e);
			}
		});

		return ret;
	},
	getRLPutable : function ()
	{
		var ret = [];


		if (hand.cards.length == 1)
		{
			var h = hand.cards[0];
			// XXX: getRLVisible is about as good as anything here.
			this.getRLVisible().forEach(function (e)
			{
				var c = e.card;
				if ((getColor(c) == getColor(h)
						&& (getRank(c) + 1)
							== getRank(h))
					|| (!c && getRank(h) == enum_rank.ACE))
				{
					ret.push(e);
				}
			});
		}

		return ret;
	}
};
table.tableau =
{
	x : MARGINLEFT,
	y : MARGINTOP + CARDHEIGHT + DISTVERT,
	cards : new Array([], [], [], [], [], [], []),
	getRLVisible : function ()
	{
		var ret = [];

		for (var i = 0 ; i < 7 ; i++)
		{
			for (var j = 0 ; j < this.cards[i].length ; j++)
			{
				ret.push(new RenderableCard(
					this.cards[i][j],
					this.x + i * (CARDWIDTH + DISTHORZ),
					this.y + j * DISTVERT, this.cards, i));
			}
		}

		return ret;
	},
	getRLPickable : function ()
	{
		var ret = [];

		// XXX: Using getRLVisible is about as good as anything here.
		this.getRLVisible().forEach(function (e)
		{
			if (isFacingUp(e.card))
			{
				ret.push(e);
			}
		});

		return ret;
	},
	getRLPutable : function (card)
	{
		var ret = [];

		// TODO: Implement

		return ret;
	}
};
table.getRLVisible = function ()
{
	/*
	 * XXX: I prefer prototype call. I find it
	 *      to be more readable than calling
	 *      concat on first array with
	 *      the others as arguments.
	 */
	return Array.prototype.concat.call(
		this.deck.getRLVisible(),
		this.waste.getRLVisible(),
		this.foundation.getRLVisible(),
		this.tableau.getRLVisible());
};
table.getRLPickable = function ()
{
	return Array.prototype.concat.call(
		this.waste.getRLPickable(),
		this.foundation.getRLPickable(),
		this.tableau.getRLPickable());
};
table.getRLPutable = function ()
{
	return Array.prototype.concat.call(
		this.foundation.getRLPutable(),
		this.tableau.getRLPutable());
};
table.initialize = function ()
{
	/*
	 * Initialize game.
	 *
	 * TODO: Get initial state from server.
	 */

	// Initialize deck
	//for (var i = 0 ; i < 24 ; i++)
	for (var i = 0 ; i < 18 ; i++)
	{
		this.deck.cards[i] = UNKNOWNCARD;
	}

	// Waste is empty as it should be. No further initialization required.
	// Initialize with a few cards for testing.
	this.waste.cards = [43 | FACE_UP, 42 | FACE_UP, 41 | FACE_UP,
		40 | FACE_UP, 39 | FACE_UP, 38 | FACE_UP];

	// Initialize foundations
	for (var i = 0 ; i < 4 ; i++)
	{
		this.foundation.cards[i] = NULLCARD;
	}

	// Initialize tableaus
	for (var i = 0 ; i < 7 ; i++)
	{
		var j;
		for (j = 0 ; j < i ; j++)
		{
			this.tableau.cards[i][j] = UNKNOWNCARD;
		}
	}
	this.tableau.cards[0][0] = 77 | FACE_UP;
	this.tableau.cards[1][1] = 70 | FACE_UP;
	this.tableau.cards[2][2] = 61 | FACE_UP;
	this.tableau.cards[3][3] = 56 | FACE_UP;
	this.tableau.cards[4][4] = 52 | FACE_UP;
	this.tableau.cards[5][5] = 49 | FACE_UP;
	this.tableau.cards[6][6] = 44 | FACE_UP;
};

table.initialize();

function cardRenderer (c, ctx)
{
	return function (rc)
	{
		ctx.fillStyle = 'rgb(' + rc.card + ',0,0)';
		ctx.fillRect(Math.floor(rc.x * (c.width / CANVASWIDTH)),
			Math.floor(rc.y * (c.height / CANVASHEIGHT)),
			Math.floor(CARDWIDTH * (c.width / CANVASWIDTH)),
			Math.floor(CARDHEIGHT * (c.height / CANVASHEIGHT)));
	}
}

var hand = {};
hand.x = 0;
hand.y = 0;
hand.is_holding = false;
hand.offs_x = 0;
hand.offs_y = 0;
hand.cards = new Array();

function renderCard (c, ctx, card, rx, ry)
{
	ctx.fillStyle = 'rgb(' + card + ',0,0)';
	ctx.fillRect(Math.floor(rx * (c.width / CANVASWIDTH)),
		Math.floor(ry * (c.height / CANVASHEIGHT)),
		Math.floor(CARDWIDTH * (c.width / CANVASWIDTH)),
		Math.floor(CARDHEIGHT * (c.height / CANVASHEIGHT)));
}

var renderRenderableCardToTable = cardRenderer(t, ttx);
function renderTable ()
{
	ttx.clearRect(0, 0, t.width, t.height);

	table.getRLVisible().forEach(renderRenderableCardToTable);
}

var renderRenderableCardToPickable = cardRenderer(pk, pktx);
function renderPickable ()
{
	pktx.clearRect(0, 0, pk.width, pk.height);

	table.getRLPickable().forEach(renderRenderableCardToPickable);
}

var renderRenderableCardToPutable = cardRenderer(pt, pttx);
function renderPutable ()
{
	pttx.clearRect(0, 0, pt.width, pt.height);

	table.getRLPutable().forEach(renderRenderableCardToPutable);
}

var renderRenderableCardToHand = cardRenderer(gf, gftx);
function renderHand ()
{
	gftx.clearRect(0, 0, gf.width, gf.height);

	// Testing
	gftx.fillStyle = 'rgb(0,0,255)';
	gftx.fillRect(0, 0, gf.width, gf.height);
}

function renderGame ()
{
	gtx.clearRect(0, 0, g.width, g.height);

	gtx.drawImage(t, 0, 0);

	if (hand.is_holding)
	{
		gtx.drawImage(gf, hand.x, hand.y);
		window.requestAnimationFrame(renderGame);
	}
}

function pick (e)
{
	var x, y;
	if (window.TouchEvent && e instanceof TouchEvent)
	{
		x = e.touches[0].pageX - g.offsetLeft;
		y = e.touches[0].pageY - g.offsetTop;
	}
	else
	{
		x = e.layerX;
		y = e.layerY;
	}

	var pixel = pktx.getImageData(x, y, 1, 1);
	var card = pixel.data[0];

	if (card && card != UNKNOWNCARD) // Valid card
	{
		// TODO: Move picked to hand.cards
		hand.is_holding = true;
		hand.x = x;
		hand.y = y;

		renderHand();
		renderPutable();
		renderTable();
		window.requestAnimationFrame(renderGame);
	}
}
g.addEventListener('mousedown', pick);
g.addEventListener('touchstart', pick);

function transpose (e)
{
	if (hand.is_holding)
	{
		var x, y;
		if (window.TouchEvent && e instanceof TouchEvent)
		{
			x = e.touches[0].pageX - g.offsetLeft;
			y = e.touches[0].pageY - g.offsetTop;
		}
		else
		{
			x = e.layerX;
			y = e.layerY;
		}

		x += hand.offs_x;
		y += hand.offs_y;

		// XXX: Limit x to margins
		hand.x = Math.max(0.1 * g.width
				- CARDWIDTH * (g.width / CANVASWIDTH),
			Math.min(x, 0.9 * g.width));
		// XXX: Limit y to margins
		hand.y = Math.max(0.1 * g.height
				- CARDHEIGHT * (g.height / CANVASHEIGHT),
			Math.min(y, 0.9 * g.height));
	}
}
g.addEventListener('mousemove', transpose);
g.addEventListener('touchmove', transpose);

function place (e)
{
	// TODO: Move placed from hand.cards
	hand.is_holding = false;
	renderTable();
	renderPickable();
}
g.addEventListener('mouseup', place);
g.addEventListener('mouseout', place);
g.addEventListener('touchend', place);

renderTable();
renderPickable();
renderGame();
</script>
