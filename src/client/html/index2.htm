<!doctype html>
<!--
/*
 * Copyright (c) 2016 Erik Nordstrøm <erik@nordstroem.no>
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
-->
<html lang=en-US>
<meta charset=UTF-8>
<meta name="viewport"
  content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Klondike</title>
<style>
* { margin: 0; padding: 0; }
body { background: #066; }
canvas {
  image-rendering: optimizeSpeed; /* Older versions of FF */
  image-rendering: -moz-crisp-edges; /* FF 6.0+ */
  image-rendering: -webkit-optimize-contrast; /* Safari */
  image-rendering: -o-crisp-edges; /* OS X & Windows Opera (12.02+) */
  image-rendering: pixelated; /* Awesome future-browsers */
  -ms-interpolation-mode: nearest-neighbor; /* IE */
  background: #063;
  display: block;
  margin: 0 auto;
}
</style>
<canvas id=game width=256 height=256></canvas>
<script id=ks>
document.body.addEventListener('touchmove', function (event) {
        event.preventDefault();
}, false);

var debug = window.location.search.replace("?", "") === 'DEBUG';

// Base units
const CARDWIDTH = 2.5;
const CARDHEIGHT = 3.5;
const CARDTHICKNESS = 0.012;
const DISTVERT = 0.5; // vertical distance
const DISTHORZ = 0.5; // horizontal distance

// Relative sizes
const MARGINTOP = DISTVERT;
const MARGINRIGHT = DISTHORZ;
const MARGINBOTTOM = DISTVERT;
const MARGINLEFT = DISTHORZ;
const CANVASWIDTH = MARGINLEFT + 7 * CARDWIDTH + 6 * DISTHORZ + MARGINRIGHT;
const CANVASHEIGHT = MARGINTOP + 2 * CARDHEIGHT + DISTVERT + 24 * DISTVERT
        + MARGINBOTTOM;

var g = document.getElementById('game');
var gtx = g.getContext('2d');

var w_min = 512;
var w_max;

function fitCanvasToDims (dw, dh)
{
	var wlim = dw;
	if (CANVASWIDTH / CANVASHEIGHT <= dw / dh)
	{
		wlim = Math.floor(dh * CANVASWIDTH / CANVASHEIGHT);
	}

	return wlim - wlim % 8;
}

function bench (cw, ch)
{
	g.width = cw;
	g.height = ch;
	var start = new Date().getTime();

	for (var i = 0 ; i < 52 ; i++)
	{
		gtx.fillStyle = 'rgb(' +
			Math.floor(Math.random() * 255) + ', ' +
			Math.floor(Math.random() * 255) + ', ' +
			Math.floor(Math.random() * 255) + ')';
		gtx.fillRect(
			Math.random() * g.width, Math.random() * g.height,
			Math.random() * g.width, Math.random() * g.height);
	}

	return new Date().getTime() - start;
}

/*
 * To the extent permitted by the frame time of 16 ms, we want to draw
 * at a resolution up to twice the one reported by the browser. The idea is to
 * try and look good on retina displays. I don't yet know if it actually does.
 * Will sometimes produce jagged edges on straight lines in Firefox
 * on my non-retina computer but that's part of the fun so I'm keeping this.
 */
w_max = fitCanvasToDims(screen.width * 2, screen.height * 2);
while (bench(w_max, Math.floor(w_max * CANVASHEIGHT / CANVASWIDTH)) > 16
	&& w_max > w_min)
{
	w_max /= 2;
}
// However, 60 FPS is no good if the graphics on screen are illegible.
if (w_max < w_min)
{
	w_max = w_min;
}

function adaptToDimsAndRes ()
{
	var w_s = fitCanvasToDims(window.innerWidth, window.innerHeight);
	g.style.width = w_s + 'px';
	g.style.height = Math.floor(w_s * CANVASHEIGHT / CANVASWIDTH) + 'px';

	var w_c = w_s * 2;
	if (w_s * 2 > w_max)
	{
		w_c = w_max;
	}

	// DOM-object size relative to canvas size.
	var ds = w_s / w_c;

	// Canvas scale relative to base units.
	var cs = w_c / CANVASWIDTH;

	g.width = w_c;
	g.height = Math.floor(CANVASHEIGHT * cs);

	const bw = 1 + Math.floor(ds);
	const cw = Math.floor(CARDWIDTH * cs);
	const ch = Math.floor(CARDHEIGHT * cs);

	var sprites = document.createElement('canvas');
	sprites.width = 15 * cw;
	sprites.height = 6 * ch;
	var stx = sprites.getContext('2d');

	const enum_color =
	{
		NO_COLOR : 0,
		HEARTS : 1,
		SPADES : 2,
		DIAMONDS : 3,
		CLUBS : 4,
		UNKNOWN_COLOR : 5
	};

	const enum_rank =
	{
		NO_RANK : 0,
		ACE : 1,
		TWO : 2,
		THREE : 3,
		FOUR : 4,
		FIVE : 5,
		SIX : 6,
		SEVEN : 7,
		EIGHT : 8,
		NINE : 9,
		TEN : 10,
		JACK : 11,
		QUEEN : 12,
		KING : 13,
		UNKNOWN_RANK : 14
	};

	const symb_color = ['', '♥', '♠', '♦', '♣', ''];

	const symb_rank = ['', 'A', '2', '3', '4', '5', '6',
		'7', '8', '9', '10', 'J', 'Q', 'K', ''];

	stx.fillStyle = 'rgb(0,0,0)';
	stx.fillRect(0, 0, sprites.width, sprites.height);

	stx.fillStyle = 'rgb(128,128,128)';
	stx.fillRect(enum_rank.NO_RANK * cw,
		enum_color.NO_COLOR * ch, cw, ch);

	stx.textBaseline = 'top';
	stx.font = ((cw - (cw % 3))/3) + 'px serif';
	for (var i = enum_color.HEARTS ; i <= enum_color.CLUBS ; i++)
	{
		for (var j = enum_rank.ACE ; j <= enum_rank.KING ; j++)
		{
			stx.fillStyle = 'rgb(255,255,255)';
			stx.fillRect((j * cw) + bw, (i * ch) + bw,
				cw - 2 * bw, ch - 2 * bw);
			stx.fillStyle = 'rgb(' + (i & 1) * 255 + ',0,0)';
			stx.fillText(symb_rank[j] + symb_color[i],
				(j * cw) + bw + 3, (i * ch) + bw + 4);
		}
	}

	stx.fillStyle = 'rgb(0,0,255)';
	stx.fillRect((enum_rank.UNKNOWN_RANK * cw) + bw,
		(enum_color.UNKNOWN_COLOR * ch) + bw,
		cw - 2 * bw, ch - 2 * bw);

	if (debug)
	{
		var old_sprites = document.getElementById('sprt');
		if (old_sprites)
		{
			old_sprites.parentNode.removeChild(old_sprites);
		}

		var ks = document.getElementById('ks');

		sprites.setAttribute('id', 'sprt');
		sprites.style.width = Math.floor(sprites.width * ds) + 'px';
		sprites.style.height = Math.floor(sprites.height * ds) + 'px';
		document.body.insertBefore(sprites, ks);
		document.body.insertBefore(document.createTextNode('\n'), ks);
	}

	// TODO: Remove development testing drawing.
	gtx.drawImage(sprites, enum_rank.KING * cw, enum_color.SPADES * ch,
		cw, ch, DISTHORZ * cs, DISTVERT * cs, cw, ch);
}

adaptToDimsAndRes();

var id_ra;
window.onresize = function ()
{
	clearTimeout(id_ra);
	id_ra = setTimeout(adaptToDimsAndRes, 64);
};
</script>
